<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamVault - Watch History & Navigation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://npmcdn.com/parse/dist/parse.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0a0a0a; color: #f3f4f6; }
        .bg-purple { background-color: #a855f7; }
        .glass { background: rgba(23, 23, 23, 0.8); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.05); }
        
        .watched-banner {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(168, 85, 247, 0.95);
            padding: 6px 4px;
            color: white;
            font-size: 8.5px;
            font-weight: 700;
            text-align: center;
            line-height: 1.2;
            backdrop-filter: blur(8px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
        }

        .history-card:hover img, .gallery-card:hover img { transform: scale(1.05); }
        
        .delete-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 22px;
            height: 22px;
            background-color: #ef4444;
            color: white;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 60;
            cursor: pointer;
            border: 2px solid #0a0a0a;
            transition: all 0.2s ease;
        }
        .delete-btn:hover { transform: scale(1.15); background-color: #dc2626; }

        /* Updated Watched Style */
        .ep-watched { color: #22c55e !important; font-weight: bold; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #262626; border-radius: 10px; }

        .episode-nav-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 12px;
            background: #1a1a1a;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .episode-nav-btn:hover:not(:disabled) {
            background: #262626;
            border-color: #a855f7;
        }
        .episode-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Ensure select options styling is visible in various browsers */
        option { background-color: #1a1a1a; color: white; }
    </style>
</head>
<body class="pb-20">

    <header class="sticky top-0 z-50 glass py-4 px-6 border-b border-white/5">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row items-center justify-between gap-4">
            <div class="flex items-center gap-3 cursor-pointer" onclick="location.reload()">
                <div class="w-10 h-10 bg-purple rounded-xl flex items-center justify-center">
                    <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M2 6a2 2 0 012-2h12a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path></svg>
                </div>
                <h1 class="text-xl font-bold tracking-tight">StreamVault</h1>
            </div>

            <div class="relative w-full max-w-md">
                <input type="text" id="searchInput" placeholder="Search movies or shows..." class="w-full bg-[#1a1a1a] border border-white/10 rounded-full py-2 px-10 focus:outline-none focus:border-purple-500 text-sm">
                <svg class="w-4 h-4 absolute left-4 top-3 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
            </div>

            <div class="flex bg-[#1a1a1a] p-1 rounded-lg border border-white/5">
                <button id="showMoviesBtn" class="px-5 py-1.5 rounded-md text-sm font-semibold bg-purple transition-all">Movies</button>
                <button id="showTvBtn" class="px-5 py-1.5 rounded-md text-sm font-semibold text-gray-400 hover:text-white transition-all">TV Shows</button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-6 mt-8">
        <!-- Player -->
        <section id="playerSection" class="hidden mb-12">
            <div class="glass p-4 rounded-2xl shadow-2xl">
                <div id="videoContainer" class="aspect-video bg-black rounded-xl overflow-hidden relative">
                    <iframe id="mainPlayer" src="" class="w-full h-full" allowfullscreen frameborder="0"></iframe>
                </div>
                
                <div class="mt-6">
                    <div class="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4 border-b border-white/5 pb-6">
                        <div>
                            <h2 id="playerTitle" class="text-2xl font-bold text-white">Title</h2>
                            <p id="playerSub" class="text-sm text-purple-400 font-semibold uppercase mt-1"></p>
                        </div>
                        <div class="flex flex-wrap gap-3 w-full lg:w-auto">
                            <select id="srcSelect" class="bg-[#1a1a1a] text-sm border border-white/10 rounded-lg px-4 py-2.5 outline-none hover:border-purple-500"></select>
                            <div id="tvSelectors" class="hidden flex gap-2">
                                <select id="seasonSelect" class="bg-[#1a1a1a] text-sm border border-white/10 rounded-lg px-4 py-2.5 outline-none hover:border-purple-500"></select>
                                <select id="episodeSelect" class="bg-[#1a1a1a] text-sm border border-white/10 rounded-lg px-4 py-2.5 outline-none hover:border-purple-500"></select>
                            </div>
                        </div>
                    </div>

                    <div id="episodeInfo" class="hidden mt-6 flex flex-col md:flex-row gap-6">
                        <div id="episodePosterContainer" class="w-full md:w-64 h-36 flex-shrink-0 rounded-xl overflow-hidden bg-[#1a1a1a] border border-white/10">
                            <img id="episodeStill" src="" class="w-full h-full object-cover opacity-80" alt="Episode Still">
                        </div>
                        <div class="flex-grow">
                            <div class="flex items-center justify-between mb-3">
                                <h3 id="epTitleDisplay" class="text-lg font-bold text-white">Episode Name</h3>
                                <div class="flex gap-2">
                                    <button id="prevEpBtn" class="episode-nav-btn">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                                        Prev
                                    </button>
                                    <button id="nextEpBtn" class="episode-nav-btn">
                                        Next
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                                    </button>
                                </div>
                            </div>
                            <p id="epOverview" class="text-sm text-gray-400 leading-relaxed line-clamp-3">No description available for this episode.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- History -->
        <section id="historySection" class="hidden mb-12">
            <h3 class="text-xs font-bold text-gray-500 uppercase tracking-[0.2em] mb-5">Recent Activity</h3>
            <div id="historyGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6"></div>
        </section>

        <!-- Gallery -->
        <section>
            <h3 id="galleryTitle" class="text-xl font-bold mb-8 text-white">Popular Movies</h3>
            <div id="galleryGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-6"></div>
            <div class="flex justify-center items-center gap-10 mt-16 mb-10">
                <button id="prevBtn" class="w-12 h-12 bg-[#1a1a1a] rounded-full flex items-center justify-center text-gray-400 hover:bg-purple hover:text-white disabled:opacity-20 transition">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <span id="pageTxt" class="text-sm font-bold text-gray-500 uppercase tracking-widest">Page 1</span>
                <button id="nextBtn" class="w-12 h-12 bg-[#1a1a1a] rounded-full flex items-center justify-center text-gray-400 hover:bg-purple hover:text-white transition">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </button>
            </div>
        </section>
    </main>

    <script>
        const CONFIG = {
            PARSE_APP_ID: "GUIFjcRB8wEOGXbBfBl8zu0yCRXLwcOTTT4dGcOT",
            PARSE_JS_KEY: "qqX1cAGsgv3yg2n8Gda2Le1CH7OUQDB7BvQdONRf",
            TMDB_KEY: '1070730380f5fee0d87cf0382670b255'
        };

        const availableSources = [
            { id: 'videasy', name: 'VidEasy', urls: { movie: 'https://player.videasy.net/movie/{id}?color=8834ec', tv: 'https://player.videasy.net/tv/{id}/{season}/{episode}?nextEpisode=true&color=8834ec' } },
            { id: 'vidsrcsu', name: 'vidsrc.su', urls: { movie: 'https://vidsrc.su/embed/movie/{id}', tv: 'https://vidsrc.su/embed/tv/{id}/{season}/{episode}' } },
            { id: 'vidsrcvip', name: 'vidsrc.vip', urls: { movie: 'https://vidsrc.vip/embed/movie/{id}', tv: 'https://vidsrc.vip/embed/tv/{id}/{season}/{episode}' } },
            { id: 'vidsrccc', name: "VidSrcCC", urls: { movie: "https://vidsrc.cc/v2/embed/movie/{id}?autoPlay=false", tv: "https://vidsrc.cc/v2/embed/tv/{id}/{season}/{episode}?nextEpisode=true&autoPlay=false" } },
            { id: 'flicky', name: 'Flicky', urls: { movie: 'https://flicky.host/embed/movie/?id={id}', tv: 'https://flicky.host/embed/tv/?id={id}&season={season}&episode={episode}' } },
            { id: 'wplayme', name: 'Wplay.me', urls: { movie: 'https://embed.wplay.me/embed/movie/{id}', tv: 'https://embed.wplay.me/embed/tv/{id}/{season}/{episode}' } },
            { id: 'rive', name: 'RiveStream', urls: { movie: 'https://rivestream.org/embed?type=movie&id={id}', tv: 'https://rivestream.org/embed?type=tv&id={id}&season={season}&episode={episode}' } },
            { id: 'vidpop', name: 'Vidpop', urls: { movie: 'https://www.vidpop.xyz/embed/?id={id}', tv: 'https://www.vidpop.xyz/embed/?id={id}&season={season}&episode={episode}' } },
            { id: 'vidjoy', name: 'VidJoy', urls: { movie: 'https://vidjoy.pro/embed/movie/{id}', tv: 'https://vidjoy.pro/embed/tv/{id}/{season}/{episode}' } },
            { id: 'pstream', name: 'P-Stream', urls: { movie: 'https://iframe.pstream.org/embed/tmdb-movie-{id}', tv: 'https://iframe.pstream.org/embed/tmdb-tv-{id}/{season}/{episode}' } }
        ];

        const noSandboxSources = ['videasy', 'vidsrcsu', 'vidsrcvip'];

        let state = { user: null, type: 'movie', page: 1, query: '', history: {}, current: null, currentEpisodes: [] };

        async function init() {
            Parse.initialize(CONFIG.PARSE_APP_ID, CONFIG.PARSE_JS_KEY);
            Parse.serverURL = "https://parseapi.back4app.com";
            let user = Parse.User.current() || await Parse.User.logIn("vault_user", "vault_pass").catch(() => {
                const u = new Parse.User(); u.set("username", "vault_user"); u.set("password", "vault_pass"); return u.signUp();
            });
            state.user = user;
            await fetchHistory();
            renderSources(); fetchGallery(); setupEvents();
        }

        function formatDate(date) {
            if (!date) return "--/--/----";
            const d = new Date(date);
            return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        }

        async function fetchHistory() {
            const query = new Parse.Query("WatchedItem");
            query.equalTo("user", state.user);
            query.descending("watchedDate");
            try {
                const results = await query.find();
                state.history = {};
                results.forEach(item => {
                    const tmdbId = item.get("tmdbId");
                    const s = item.get("lastWatchedSeason");
                    const e = item.get("lastWatchedEpisode");
                    
                    if(!state.history[tmdbId]) state.history[tmdbId] = {};
                    
                    state.history[tmdbId][`${s}-${e}`] = {
                        id: item.id,
                        obj: item,
                        type: item.get("mediaType"),
                        season: s,
                        episode: e,
                        title: item.get("title"),
                        poster: item.get("posterPath"),
                        watchedDate: item.get("watchedDate") || item.updatedAt
                    };
                });
                renderHistory(); renderGallery();
            } catch (e) { console.error(e); }
        }

        async function saveToWatched(item, s = 0, e = 0) {
            const WatchedItem = Parse.Object.extend("WatchedItem");
            const tmdbId = item.id.toString();
            const key = `${s}-${e}`;
            
            let record;
            if (state.history[tmdbId] && state.history[tmdbId][key]) {
                record = state.history[tmdbId][key].obj;
            }
            
            if (!record) record = new WatchedItem();

            record.set("user", state.user); 
            record.set("tmdbId", tmdbId);
            record.set("mediaType", state.type); 
            record.set("lastWatchedSeason", parseInt(s));
            record.set("lastWatchedEpisode", parseInt(e)); 
            record.set("title", item.title || item.name);
            record.set("posterPath", item.poster_path); 
            record.set("watchedDate", new Date());
            
            try {
                const saved = await record.save();
                if(!state.history[tmdbId]) state.history[tmdbId] = {};
                
                state.history[tmdbId][key] = {
                    id: saved.id,
                    obj: saved, type: state.type, season: s, episode: e,
                    title: item.title || item.name, poster: item.poster_path, watchedDate: new Date()
                };
                renderHistory(); renderGallery();
            } catch (err) { console.error(err); }
        }

        async function deleteHistoryItem(tmdbId, event) {
            event.stopPropagation();
            try {
                const query = new Parse.Query("WatchedItem");
                query.equalTo("user", state.user);
                query.equalTo("tmdbId", tmdbId);
                const results = await query.find();
                await Parse.Object.destroyAll(results);
                delete state.history[tmdbId];
                renderHistory(); 
                renderGallery();
                if (state.current && state.current.id.toString() === tmdbId) {
                    const s = document.getElementById('seasonSelect').value;
                    const e = document.getElementById('episodeSelect').value;
                    updateEpisodeDropdown(s, e);
                }
            } catch (err) { console.error(err); }
        }

        function renderHistory() {
            const grid = document.getElementById('historyGrid');
            const section = document.getElementById('historySection');
            const uniqueShowsLatest = [];
            for (const tmdbId in state.history) {
                const episodes = Object.values(state.history[tmdbId]);
                const latest = episodes.sort((a,b) => b.watchedDate - a.watchedDate)[0];
                uniqueShowsLatest.push({ tmdbId, ...latest });
            }
            const sortedRecent = uniqueShowsLatest.sort((a,b) => b.watchedDate - a.watchedDate).slice(0, 8);
            if (sortedRecent.length === 0) { section.classList.add('hidden'); return; }
            section.classList.remove('hidden');
            grid.innerHTML = sortedRecent.map((data) => {
                return `
                <div class="history-card relative flex items-center gap-4 p-3 bg-[#131313] rounded-2xl cursor-pointer hover:bg-white/5 transition-all border border-white/5 shadow-lg" 
                     onclick="loadContent(${data.tmdbId}, '${data.type}', ${data.season}, ${data.episode})">
                    <div onclick="deleteHistoryItem('${data.tmdbId}', event)" class="delete-btn">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </div>
                    <div class="w-14 h-20 flex-shrink-0 overflow-hidden rounded-xl">
                        <img src="https://image.tmdb.org/t/p/w200${data.poster}" class="w-full h-full object-cover">
                    </div>
                    <div class="overflow-hidden">
                        <h4 class="text-sm font-bold truncate text-white mb-1">${data.title}</h4>
                        <div class="flex flex-col gap-0.5">
                             <span class="text-[10px] text-purple-400 font-extrabold uppercase tracking-wider">${data.type === 'tv' ? `S${data.season} E${data.episode}` : 'Movie'}</span>
                             <span class="text-[9px] text-gray-500 font-semibold">Watched: ${formatDate(data.watchedDate)}</span>
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        async function fetchGallery() {
            const url = state.query 
                ? `https://api.themoviedb.org/3/search/${state.type}?api_key=${CONFIG.TMDB_KEY}&query=${encodeURIComponent(state.query)}&page=${state.page}`
                : `https://api.themoviedb.org/3/${state.type}/popular?api_key=${CONFIG.TMDB_KEY}&page=${state.page}`;
            const res = await fetch(url); const data = await res.json();
            galleryData = data.results; renderGallery();
            document.getElementById('pageTxt').innerText = `Page ${data.page}`;
            document.getElementById('prevBtn').disabled = data.page <= 1;
        }

        function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            grid.innerHTML = galleryData.map(item => {
                const historyObj = state.history[item.id.toString()] || {};
                const episodes = Object.values(historyObj);
                const watchData = episodes.sort((a,b) => b.watchedDate - a.watchedDate)[0];
                let bannerHtml = watchData ? `<div class="watched-banner">${watchData.type === 'tv' ? `S${watchData.season} E${watchData.episode}` : 'Movie'} Last Watched: ${formatDate(watchData.watchedDate)}</div>` : '';
                return `
                <div class="gallery-card relative group cursor-pointer" onclick="loadContent(${item.id}, '${state.type}', ${watchData?.season || 1}, ${watchData?.episode || 1})">
                    <div class="aspect-[2/3] rounded-2xl overflow-hidden bg-[#1a1a1a] mb-3 shadow-xl border border-white/5 relative">
                        <img src="https://image.tmdb.org/t/p/w400${item.poster_path}" class="w-full h-full object-cover group-hover:scale-110 transition duration-700">
                        ${bannerHtml}
                    </div>
                    <h4 class="text-sm font-bold truncate px-1 text-gray-200">${item.title || item.name}</h4>
                    <p class="text-xs text-gray-500 px-1 mt-0.5">${(item.release_date || item.first_air_date || '').split('-')[0] || 'N/A'}</p>
                </div>
                `;
            }).join('');
        }

        async function loadContent(id, type, s = 1, e = 1) {
            state.type = type; 
            const res = await fetch(`https://api.themoviedb.org/3/${type}/${id}?api_key=${CONFIG.TMDB_KEY}`);
            state.current = await res.json();
            document.getElementById('playerSection').classList.remove('hidden');
            document.getElementById('playerTitle').innerText = state.current.title || state.current.name;
            window.scrollTo({ top: 0, behavior: 'smooth' });
            if (type === 'tv') {
                document.getElementById('tvSelectors').classList.remove('hidden');
                document.getElementById('episodeInfo').classList.remove('hidden');
                const seasons = state.current.seasons.filter(x => x.season_number > 0);
                const sSelect = document.getElementById('seasonSelect');
                sSelect.innerHTML = seasons.map(x => `<option value="${x.season_number}">Season ${x.season_number}</option>`).join('');
                sSelect.value = s; 
                await updateEpisodes(s, e);
            } else {
                document.getElementById('tvSelectors').classList.add('hidden');
                document.getElementById('episodeInfo').classList.add('hidden');
                document.getElementById('playerSub').innerText = "Movie Stream";
                updatePlayer(); 
                saveToWatched(state.current);
            }
        }

        async function updateEpisodes(sNum, eNum = 1) {
            const res = await fetch(`https://api.themoviedb.org/3/tv/${state.current.id}/season/${sNum}?api_key=${CONFIG.TMDB_KEY}`);
            const data = await res.json();
            state.currentEpisodes = data.episodes;
            updateEpisodeDropdown(sNum, eNum);
            updateEpisodeDetails(eNum);
            updatePlayer(); 
            saveToWatched(state.current, sNum, eNum);
        }

        function updateEpisodeDropdown(sNum, currentENum) {
            const eSelect = document.getElementById('episodeSelect');
            const historyForThisShow = state.history[state.current.id.toString()] || {};
            eSelect.innerHTML = state.currentEpisodes.map(ep => {
                const key = `${sNum}-${ep.episode_number}`;
                const isWatched = !!historyForThisShow[key];
                return `<option value="${ep.episode_number}" class="${isWatched ? 'ep-watched' : ''}">
                    ${isWatched ? '✓ ' : ''}Episode ${ep.episode_number}
                </option>`;
            }).join('');
            if (currentENum) eSelect.value = currentENum;
        }

        function updateEpisodeDetails(eNum) {
            const episode = state.currentEpisodes.find(ep => ep.episode_number == eNum);
            if (!episode) return;
            document.getElementById('playerSub').innerText = `Season ${episode.season_number} • Episode ${eNum}`;
            document.getElementById('epTitleDisplay').innerText = episode.name;
            document.getElementById('epOverview').innerText = episode.overview || "No description available for this episode.";
            const stillUrl = episode.still_path ? `https://image.tmdb.org/t/p/w500${episode.still_path}` : `https://image.tmdb.org/t/p/w500${state.current.backdrop_path}`;
            document.getElementById('episodeStill').src = stillUrl;
            const sNum = document.getElementById('seasonSelect').value;
            const maxEpisodes = state.currentEpisodes.length;
            const maxSeasons = state.current.seasons.filter(x => x.season_number > 0).length;
            document.getElementById('prevEpBtn').disabled = (eNum <= 1 && sNum <= 1);
            document.getElementById('nextEpBtn').disabled = (eNum >= maxEpisodes && sNum >= maxSeasons);
        }

        function updatePlayer() {
            const srcId = document.getElementById('srcSelect').value;
            const src = availableSources.find(x => x.id === srcId) || availableSources[0];
            const player = document.getElementById('mainPlayer');
            const s = document.getElementById('seasonSelect').value || 1; 
            const e = document.getElementById('episodeSelect').value || 1;
            if (noSandboxSources.includes(src.id)) { player.removeAttribute('sandbox'); } else { player.setAttribute('sandbox', 'allow-forms allow-pointer-lock allow-same-origin allow-scripts allow-top-navigation'); }
            const url = state.type === 'movie' ? src.urls.movie.replace('{id}', state.current.id) : src.urls.tv.replace('{id}', state.current.id).replace('{season}', s).replace('{episode}', e);
            player.src = url;
        }

        async function navigateEpisode(dir) {
            let s = parseInt(document.getElementById('seasonSelect').value);
            let e = parseInt(document.getElementById('episodeSelect').value);
            const maxE = state.currentEpisodes.length;
            if (dir === 'next') {
                if (e < maxE) { e++; } else {
                    const seasons = state.current.seasons.filter(x => x.season_number > 0);
                    if (s < seasons.length) { s++; e = 1; document.getElementById('seasonSelect').value = s; await updateEpisodes(s, e); return; }
                }
            } else {
                if (e > 1) { e--; } else if (s > 1) {
                    s--; document.getElementById('seasonSelect').value = s;
                    const res = await fetch(`https://api.themoviedb.org/3/tv/${state.current.id}/season/${s}?api_key=${CONFIG.TMDB_KEY}`);
                    const data = await res.json(); e = data.episodes.length; await updateEpisodes(s, e); return;
                }
            }
            document.getElementById('episodeSelect').value = e;
            updateEpisodeDetails(e); updateEpisodeDropdown(s, e); updatePlayer(); saveToWatched(state.current, s, e);
        }

        function renderSources() { document.getElementById('srcSelect').innerHTML = availableSources.map(x => `<option value="${x.id}">${x.name}</option>`).join(''); }

        function setupEvents() {
            document.getElementById('showMoviesBtn').onclick = () => { state.type = 'movie'; state.page = 1; document.getElementById('showMoviesBtn').classList.add('bg-purple'); document.getElementById('showTvBtn').classList.remove('bg-purple'); fetchGallery(); };
            document.getElementById('showTvBtn').onclick = () => { state.type = 'tv'; state.page = 1; document.getElementById('showTvBtn').classList.add('bg-purple'); document.getElementById('showMoviesBtn').classList.remove('bg-purple'); fetchGallery(); };
            document.getElementById('searchInput').oninput = (e) => { state.query = e.target.value; state.page = 1; fetchGallery(); };
            document.getElementById('prevBtn').onclick = () => { if (state.page > 1) { state.page--; fetchGallery(); } };
            document.getElementById('nextBtn').onclick = () => { state.page++; fetchGallery(); };
            document.getElementById('srcSelect').onchange = updatePlayer;
            document.getElementById('seasonSelect').onchange = (e) => updateEpisodes(e.target.value);
            document.getElementById('episodeSelect').onchange = (e) => {
                const s = document.getElementById('seasonSelect').value;
                const eVal = e.target.value;
                updateEpisodeDetails(eVal); updateEpisodeDropdown(s, eVal); updatePlayer(); saveToWatched(state.current, s, eVal);
            };
            document.getElementById('prevEpBtn').onclick = () => navigateEpisode('prev');
            document.getElementById('nextEpBtn').onclick = () => navigateEpisode('next');
        }
        init();
    </script>
</body>
</html>

